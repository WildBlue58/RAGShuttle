# OpenSpec 工作流说明

> 返回 [项目主页](../../README.md) | [文档中心](../../docs/README.md)

本文档说明如何在 RAGShuttle (羽智RAG) 项目中使用 OpenSpec 进行规范驱动的开发。

## 什么是 OpenSpec？

OpenSpec 是一个规范驱动的开发工作流工具，通过维护清晰的规范（Specs）和变更提案（Change Proposals）来管理项目开发。它帮助我们：

- 在编码前明确需求和预期行为
- 追踪变更的影响范围
- 保持规范与实现的一致性
- 提供清晰的变更历史记录

## 核心概念

### 三个目录结构

```text
openspec/
├── project.md              # 项目上下文（技术栈、约定、领域知识）
├── specs/                  # 当前规范 - 已实现的功能
│   └── [capability]/       # 单一功能模块
│       └── spec.md         # 需求规范和场景
└── changes/                # 变更提案 - 计划中的更改
    ├── [change-id]/        # 变更标识（kebab-case，动词开头）
    │   ├── proposal.md     # 为什么、做什么、影响范围
    │   ├── tasks.md        # 实现任务清单
    │   ├── design.md       # 技术设计（可选）
    │   └── specs/          # 规范变更
    │       └── [capability]/
    │           └── spec.md # ADDED/MODIFIED/REMOVED 需求
    └── archive/            # 已完成的变更
```

### 三种状态

1. **specs/** - 已实现并部署的功能（当前真相）
2. **changes/** - 提案中的功能（待实现）
3. **changes/archive/** - 已完成的功能（历史记录）

## 三阶段工作流

### 阶段 1：创建变更提案

当你需要添加功能、修改架构或进行破坏性变更时，创建变更提案。

#### 何时创建提案？

✅ **需要提案**：

- 新功能或新能力
- 破坏性变更（API、数据库结构）
- 架构或模式变更
- 性能优化（改变行为）
- 安全模式更新

❌ **不需要提案**：

- Bug 修复（恢复预期行为）
- 拼写错误、格式化、注释
- 依赖更新（非破坏性）
- 配置更改
- 为现有行为编写测试

#### 创建提案步骤

1. **查看现有状态**

   ```bash
   openspec list              # 查看活跃的变更
   openspec list --specs      # 查看现有功能规范
   openspec show [spec-id]    # 查看特定规范详情
   ```

2. **选择唯一的变更 ID**
   - 使用 kebab-case 格式
   - 动词开头：`add-`, `update-`, `remove-`, `refactor-`
   - 例如：`add-chat-history`, `update-rag-threshold`

3. **创建提案目录结构**

   ```bash
   mkdir -p openspec/changes/add-feature-name/specs/capability-name
   ```

4. **编写 proposal.md**

   ```markdown
   ## 为什么
   [1-2 句话说明问题或机会]
   
   ## 变更内容
   - [列出具体变更]
   - [标记破坏性变更：**BREAKING**]
   
   ## 影响范围
   - 受影响的功能模块：[列表]
   - 受影响的代码文件：[关键文件]
   ```

5. **编写规范变更（specs/[capability]/spec.md）**

   ```markdown
   ## ADDED Requirements
   ### Requirement: 新功能名称
   系统 SHALL [描述功能]
   
   #### Scenario: 成功场景
   - **WHEN** [触发条件]
   - **THEN** [预期结果]
   
   ## MODIFIED Requirements
   ### Requirement: 现有功能
   [完整修改后的需求，包含所有场景]
   
   ## REMOVED Requirements
   ### Requirement: 旧功能
   **原因**: [为什么移除]
   **迁移**: [如何处理]
   ```

6. **创建 tasks.md**

   ```markdown
   ## 1. 实现阶段
   - [ ] 1.1 任务 1
   - [ ] 1.2 任务 2
   ```

7. **（可选）创建 design.md**
   仅在以下情况创建：
   - 跨模块变更或新架构模式
   - 新的外部依赖或重大数据模型变更
   - 安全、性能或迁移复杂性
   - 需要技术决策的模糊问题

8. **验证提案**

   ```bash
   openspec validate add-feature-name --strict
   ```

### 阶段 2：实现变更

在提案获得批准后，按照任务清单逐步实现。

#### 实现步骤

1. **阅读提案文档**
   - 理解 `proposal.md` 中的目标和影响
   - 查看 `design.md`（如果存在）了解技术决策
   - 查看 `tasks.md` 获取实现清单

2. **按顺序实现任务**
   - 从 `tasks.md` 的第一个任务开始
   - 完成一个任务后勾选 `[x]`
   - 按照任务顺序执行，不要跳步

3. **保持规范与代码一致**
   - 实现的功能应该符合 `specs/` 中的规范
   - 如果发现规范不完整，更新变更提案

4. **确认完成**
   - 确保 `tasks.md` 中所有任务都标记为完成
   - 运行测试验证功能
   - 确认规范与实现一致

### 阶段 3：归档变更

部署完成后，将变更归档。

#### 归档步骤

1. **更新规范**
   - 变更提案中的 `specs/` 内容会被合并到 `specs/` 目录
   - 确保规范反映最新的实现状态

2. **移动变更目录**

   ```bash
   openspec archive add-feature-name --yes
   ```

   或手动：

   ```bash
   mv openspec/changes/add-feature-name openspec/changes/archive/2025-10-31-add-feature-name
   ```

3. **验证归档**

   ```bash
   openspec validate --strict
   ```

## 规范文件格式

### 关键格式要求

1. **场景格式**（必须使用 `#### Scenario:`）

   ```markdown
   #### Scenario: 场景名称
   - **WHEN** [条件]
   - **THEN** [结果]
   - **AND** [附加条件或结果]
   ```

   ❌ 错误格式：
   - `- **Scenario:** ...` （不要用列表项）
   - `**Scenario**: ...` （不要用粗体）
   - `### Scenario: ...` （不要用三级标题）

2. **需求格式**

   ```markdown
   ### Requirement: 需求名称
   系统 SHALL [描述需求]
   
   #### Scenario: [至少一个场景]
   ```

3. **变更操作标签**
   - `## ADDED Requirements` - 新增功能
   - `## MODIFIED Requirements` - 修改现有功能
   - `## REMOVED Requirements` - 移除功能
   - `## RENAMED Requirements` - 重命名功能

### 重要提示

- **每个需求必须至少有一个场景**
- **MODIFIED 需求必须包含完整的需求内容**（不能只写修改部分）
- **使用 SHALL/MUST 表示规范性需求**（避免 should/may）

## 常用命令

```bash
# 查看变更和规范列表
openspec list                  # 活跃变更
openspec list --specs          # 所有规范

# 查看详情
openspec show [change-id]      # 查看变更详情
openspec show [spec-id] --type spec  # 查看规范详情

# 验证
openspec validate [change-id] --strict  # 验证变更
openspec validate --strict             # 验证所有

# 归档
openspec archive [change-id] --yes     # 归档变更

# 差异对比
openspec diff [change-id]      # 查看规范差异
```

## 最佳实践

### 变更 ID 命名

- ✅ `add-chat-history` - 清晰、动词开头
- ✅ `update-rag-threshold` - 描述具体变更
- ❌ `chat-history` - 缺少动词
- ❌ `feature-123` - 不够描述性

### 能力（Capability）命名

- ✅ `chat` - 单一目的
- ✅ `vector-search` - 动词-名词格式
- ❌ `chat-and-search` - 多个目的（应该拆分）

### 保持简单

- 默认目标：< 100 行新代码
- 单文件实现直到证明不够用
- 避免不必要的框架
- 选择成熟、验证过的模式

### 只在有数据支撑时增加复杂度

- 性能数据表明当前方案太慢
- 明确的规模要求（>1000 用户，>100MB 数据）
- 多个已证明的用例需要抽象

## 工作流程示例

### 示例：添加聊天历史功能

1. **查看现有状态**

   ```bash
   openspec list --specs  # 检查是否有 chat 相关规范
   ```

2. **创建变更**

   ```bash
   mkdir -p openspec/changes/add-chat-history/specs/chat
   ```

3. **编写提案**
   - 创建 `proposal.md` 说明为什么、做什么、影响范围
   - 创建 `tasks.md` 列出实现步骤
   - 创建 `specs/chat/spec.md` 定义新需求和场景

4. **验证**

   ```bash
   openspec validate add-chat-history --strict
   ```

5. **获得批准后实现**
   - 按照 `tasks.md` 逐步实现
   - 完成后标记所有任务为完成

6. **部署后归档**

   ```bash
   openspec archive add-chat-history --yes
   ```

## 故障排除

### 常见错误

#### "变更必须至少有一个 delta"

- 检查 `changes/[name]/specs/` 目录是否存在 `.md` 文件
- 验证文件包含操作前缀（`## ADDED Requirements`）

#### "需求必须至少有一个场景"

- 检查场景使用 `#### Scenario:` 格式（4 个 #）
- 不要使用列表项或粗体作为场景标题

### 验证失败

```bash
# 使用严格模式获取详细错误
openspec validate [change] --strict

# 查看 JSON 输出调试
openspec show [change] --json --deltas-only
```

## 记住要点

- **规范是真相** - `specs/` 反映已实现的功能
- **变更是提案** - `changes/` 是计划中的更改
- **保持同步** - 实现完成后，确保规范与代码一致
- **先规范后代码** - 在编码前明确需求和场景
- **简单优先** - 默认简单方案，只在必要时增加复杂度

通过遵循 OpenSpec 工作流，我们可以更清晰地管理项目开发，确保每个变更都有明确的规范和实现路径。
